{"id":"291f243b-7016-46a2-a2bc-8383bebb8ff0","zed":"context","version":"0.4.0","text":"\n\n\n\npicow-led-microcontroller/src\n```py picow-led-microcontroller/src/commands.py\nimport os\n\nfrom gpio import gpio\nfrom picozero import pico_temp_sensor\n\nfrom constants import VERSION\n\n\ndef config_set_pins(*args) -> None:\n    pins = []\n    for arg in list(args):\n        pins.append(int(arg))\n\n    gpio.set_pins(*pins)\n\n    return None\n\n\ndef config_get_pins(*args) -> list[int]:\n    return gpio.get_pins()\n\n\ndef info_get_temp(*args) -> float | None:\n    return pico_temp_sensor.temp\n\n\ndef info_get_disk_usage(*args) -> dict:\n    disk = os.statvfs(\"/\")\n\n    block_size = disk[0]\n    total_blocks = disk[2]\n    free_blocks = disk[3]\n\n    used = (block_size * total_blocks) - (block_size * free_blocks)\n    free = block_size * free_blocks\n\n    return {\"used\": used, \"free\": free}\n\n\ndef info_get_version(*args) -> str:\n    return VERSION\n\n\ndef led_set_color(*args) -> None:\n    duty = []\n    for arg in list(args):\n        duty.append(int(arg))\n\n    gpio.set_duty(*duty)\n\n\ndef led_get_color(*args) -> list[int]:\n    return gpio.get_duty()\n\n\n# NOTE: each command takes `*args` as parameter and\n#       returns the client response data\nCOMMANDS = {\n    \"config\": {\n        \"set\": {\n            \"pins\": config_set_pins,\n        },\n        \"get\": {\n            \"pins\": config_get_pins,\n        },\n    },\n    \"info\": {\n        \"get\": {\n            \"temp\": info_get_temp,\n            \"disk-usage\": info_get_disk_usage,\n            \"version\": info_get_version,\n        },\n    },\n    \"led\": {\n        \"set\": {\n            \"color\": led_set_color,\n        },\n        \"get\": {\n            \"color\": led_get_color,\n        },\n    },\n}\n```\n\n```py picow-led-microcontroller/src/constants.py\nVERSION = \"picow-led-micropython 1.0.0\"\nHOST = \"0.0.0.0\"\nPORT = 3000\nEND_BYTE = \"\\n\".encode()\nU16_MAX = 65535\n```\n\n```py picow-led-microcontroller/src/gpio.py\nimport json\nfrom sys import stderr\n\nfrom machine import PWM, Pin\n\nfrom constants import U16_MAX\n\n\nclass Cache:\n    def __init__(self, name):\n        self.name = name  # NOTE: \"gpio\"\n\n    def read(self) -> None | object:\n        if not self.name:\n            return None\n\n        try:\n            file_name = self.get_file_name()\n            with open(file_name, \"r\") as file:\n                return json.load(file)\n        except Exception:\n            return None\n\n    def write(self, data) -> None:\n        if not self.name:\n            return None\n\n        try:\n            file_name = self.get_file_name()\n            with open(file_name, \"w\") as file:\n                json.dump(data, file)\n        except Exception:\n            pass\n\n        return None\n\n    def get_file_name(self) -> str:\n        return f\"cache-{self.name}.json\"\n\n\nclass GPIO:\n    def __init__(self):\n        self.cache = Cache(\"gpio\")\n        self.data = {\n            \"pins\": [],\n            \"range\": {\n                \"min\": 0,\n                \"max\": 255,\n            },\n        }\n\n        data = self.cache.read()\n        if isinstance(data, dict):\n            self.data = data\n\n        self._pins = []\n        self._duty = []\n        self.setup()\n\n    def setup(self) -> None:\n        self._pins = []\n        self._duty = []\n\n        for p in self.data[\"pins\"]:\n            p = PWM(Pin(p, value=1))\n            p.freq(1000)\n            self._pins.append(p)\n            self._duty.append(self.data[\"range\"][\"min\"])\n\n        self.set_duty(*self._duty)\n\n    def set_pins(self, *pins: int) -> None:\n        self.data[\"pins\"] = list(pins)\n        self.cache.write(self.data)\n        self.setup()\n\n    def get_pins(self) -> list[int]:\n        return self.data[\"pins\"]\n\n    def set_range(self, min: int, max: int) -> None:\n        self.data[\"range\"][\"min\"] = min\n        self.data[\"range\"][\"max\"] = max\n        self.cache.write(self.data)\n\n    def get_range(self) -> tuple[int, int]:\n        return (self.data[\"range\"][\"min\"], self.data[\"range\"][\"max\"])\n\n    def set_duty(self, *duty: int) -> None:\n        self._duty = []\n\n        for i, p in enumerate(self._pins):\n            if len(duty) < i + 1:\n                value =  int((1 - (self.data[\"range\"][\"min\"] / self.data[\"range\"][\"max\"])) * U16_MAX)\n                print(f\"[DEBUG] Set pin {p} to duty {value} [duty: {self.data[\"range\"][\"min\"]}, range (max):{self.data[\"range\"][\"max\"]}]\", file=stderr)\n                p.duty_u16(value)\n                self._duty.append(self.data[\"range\"][\"min\"])\n            else:\n                value =  int((1 - (duty[i] / self.data[\"range\"][\"max\"])) * U16_MAX)\n                print(f\"[DEBUG] Set pin {p} to duty {value} [duty: {duty[i]}, range (max):{self.data[\"range\"][\"max\"]}]\", file=stderr)\n                p.duty_u16(value)\n                self._duty.append(duty[i])\n\n    def get_duty(self) -> list[int]:\n        return self._duty\n\n\ngpio = GPIO()\n```\n\n```py picow-led-microcontroller/src/main.py\nimport json\nfrom socket import SO_REUSEADDR, SOL_SOCKET, socket\nfrom sys import stderr\nfrom time import sleep\n\nimport machine\nimport network\n\nfrom commands import COMMANDS\nfrom constants import END_BYTE, HOST, PORT\nfrom secrets import PASS, SSID\n\n\ndef main():\n    setup()\n\n    server = socket()\n    server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)\n    server.bind((HOST, PORT))\n    server.listen(5)\n\n    try:\n        while True:\n            print(\n                f'[INFO ] Waiting for client on \"{HOST}:{PORT}\"',\n                file=stderr,\n            )\n            client, address = server.accept()\n            print(f'[INFO ] Connected client from \"{address}\"', file=stderr)\n\n            try:\n                handleClient(client)\n            except Exception as e:\n                print(f\"[WARN ] Handle client exception: {str(e)}\")\n                client.close()\n\n    finally:\n        disable_led()\n\n\ndef setup():\n    disable_led()\n\n    sta_if = network.WLAN(network.STA_IF)\n\n    if not sta_if.isconnected():\n        sta_if.active(True)\n\n        print(\"[DEBUG] Try to connect...\", file=stderr)\n        sta_if.connect(SSID, PASS)\n\n        retry_count = 0\n        while not sta_if.isconnected():\n            if retry_count > 20:\n                print(\"[ERROR] Connection failed, retry...\")\n                return setup()\n\n            retry_count += 1\n\n            print(\"[DEBUG] ...wait for connection...\", file=stderr)\n            sleep(0.5)\n\n    enable_led()\n    print(f\"[DEBUG] ...ifconfig={sta_if.ifconfig()}\", file=stderr)\n\n\ndef handleClient(client):\n    while True:\n        data = bytes()\n        while True:\n            chunk = client.recv(1)\n            if chunk == END_BYTE:\n                break\n\n            if chunk:\n                data += chunk\n            else:\n                break\n\n        if len(data) == 0:\n            client.close()\n            return\n\n        try:\n            data = json.loads(data.strip())\n\n        except Exception as ex:\n            print(f\"[WARN ] Convert data to JSON failed: {ex}\", file=stderr)\n            client.close()\n            return\n\n        try:\n            request = {\n                \"id\": data.get(\"id\", 0),\n                \"group\": data[\"group\"],\n                \"type\": data[\"type\"],\n                \"command\": data[\"command\"],\n                \"args\": data.get(\"args\", []),\n            }\n\n            try:\n                print(\n                    f\"[DEBUG] Run requested command: {request['group']} \"\n                    + f\"{request['type']} {request['command']} \"\n                    + f\"{request['args']}\"\n                )\n                run(client, request)\n\n            except Exception as ex:\n                print(f\"[ERROR] run failed: {ex}\", file=stderr)\n                client.close()\n                return\n\n        except Exception as ex:\n            print(f\"[WARN ] Invalid client request: {ex}\", file=stderr)\n            client.close()\n            return\n\n\ndef run(client, request):\n    response = {\n        \"id\": request[\"id\"],\n        \"error\": None,\n        \"data\": None,\n    }\n\n    try:\n        if request[\"group\"] not in COMMANDS:\n            response[\"error\"] = f'command group \"{request[\"group\"]}\" not found'\n\n        if request[\"type\"] not in COMMANDS[request[\"group\"]]:\n            response[\"error\"] = f'command type \"{request[\"type\"]}\" not found'\n\n        if request[\"command\"] not in COMMANDS[request[\"group\"]][request[\"type\"]]:\n            response[\"error\"] = f'command \"{request[\"command\"]}\" not found'\n\n        if response[\"error\"] is None:\n            response[\"data\"] = COMMANDS[request[\"group\"]][request[\"type\"]][\n                request[\"command\"]\n            ](*request[\"args\"])\n\n    except AssertionError:\n        message = \"wrong args\"\n        print(\"[ERROR] \" + message)\n        response[\"error\"] = message\n\n    except Exception as e:\n        message = f\"command failed to run: {str(e)} (type: {type(e).__name__})\"\n        print(\"[ERROR] \" + message + \": \" + str(e))\n        response[\"error\"] = message\n\n    if response[\"id\"] != -1:\n        data = json.dumps(response)\n        client.settimeout(0.5)\n        client.send(data.encode() + END_BYTE)\n        client.settimeout(None)\n\n\ndef enable_led():\n    led = machine.Pin(\"LED\", machine.Pin.OUT)\n    led.on()\n\n\ndef disable_led():\n    led = machine.Pin(\"LED\", machine.Pin.OUT)\n    led.off()\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n```py picow-led-microcontroller/src/picozero.py\nfrom machine import Pin, PWM, Timer, ADC\nfrom micropython import schedule\nfrom time import ticks_ms, ticks_us, sleep\n\n###############################################################################\n# EXCEPTIONS\n###############################################################################\n\nclass PWMChannelAlreadyInUse(Exception):\n    pass\n\nclass EventFailedScheduleQueueFull(Exception):\n    pass\n\n###############################################################################\n# SUPPORTING CLASSES\n###############################################################################\n\ndef clamp(n, low, high): return max(low, min(n, high))\n\ndef pinout(output=True):\n    \"\"\"\n    Returns a textual representation of the Raspberry Pi pico pins and functions.\n\n    :param bool output:\n        If :data:`True` (the default) the pinout will be \"printed\".\n        \n    \"\"\"\n    pins = \"\"\"        ---usb---\nGP0  1  |o     o| -1  VBUS\nGP1  2  |o     o| -2  VSYS\nGND  3  |o     o| -3  GND\nGP2  4  |o     o| -4  3V3_EN\nGP3  5  |o     o| -5  3V3(OUT)\nGP4  6  |o     o| -6           ADC_VREF\nGP5  7  |o     o| -7  GP28     ADC2\nGND  8  |o     o| -8  GND      AGND\nGP6  9  |o     o| -9  GP27     ADC1\nGP7  10 |o     o| -10 GP26     ADC0\nGP8  11 |o     o| -11 RUN\nGP9  12 |o     o| -12 GP22\nGND  13 |o     o| -13 GND\nGP10 14 |o     o| -14 GP21\nGP11 15 |o     o| -15 GP20\nGP12 16 |o     o| -16 GP19\nGP13 17 |o     o| -17 GP18\nGND  18 |o     o| -18 GND\nGP14 19 |o     o| -19 GP17\nGP15 20 |o     o| -20 GP16\n        ---------\"\"\"\n\n    if output:\n        print(pins)\n    return pins\n\nclass PinMixin:\n    \"\"\"\n    Mixin used by devices that have a single pin number.\n    \"\"\"\n\n    @property\n    def pin(self):\n        \"\"\"\n        Returns the pin number used by the device.\n        \"\"\"\n        return self._pin_num\n\n    def __str__(self):\n        return \"{} (pin {})\".format(self.__class__.__name__, self._pin_num)\n\nclass PinsMixin:\n    \"\"\"\n    Mixin used by devices that use multiple pins.\n    \"\"\"\n\n    @property\n    def pins(self):\n        \"\"\"\n        Returns a tuple of pins used by the device.\n        \"\"\"\n        return self._pin_nums\n\n    def __str__(self):\n        return \"{} (pins - {})\".format(self.__class__.__name__, self._pin_nums)\n        \nclass ValueChange:\n    \"\"\"\n    Internal class to control the value of an output device. \n\n    :param OutputDevice output_device:\n        The OutputDevice object you wish to change the value of.\n\n    :param generator:\n        A generator function that yields a 2d list of\n        ((value, seconds), *).\n        \n        The output_device's value will be set for the number of\n        seconds.\n\n    :param int n:\n        The number of times to repeat the sequence. If None, the\n        sequence will repeat forever. \n    \n    :param bool wait:\n        If True the ValueChange object will block (wait) until\n        the sequence has completed.\n    \"\"\"\n    def __init__(self, output_device, generator, n, wait):\n        self._output_device = output_device\n        self._generator = generator\n        self._n = n\n\n        self._gen = self._generator()\n        \n        self._timer = Timer()\n        self._running = True\n        self._wait = wait\n        \n        self._set_value()\n            \n    def _set_value(self, timer_obj=None):\n        if self._wait:\n            # wait for the exection to end\n            next_seq = self._get_value()\n            while next_seq is not None:\n                value, seconds = next_seq\n                \n                self._output_device._write(value)\n                sleep(seconds)\n                \n                next_seq = self._get_value()\n                \n        else:\n            # run the timer\n            next_seq = self._get_value()\n            if next_seq is not None:\n                value, seconds = next_seq\n                \n                self._output_device._write(value)            \n                self._timer.init(period=int(seconds * 1000), mode=Timer.ONE_SHOT, callback=self._set_value)\n\n        if next_seq is None:\n            # the sequence has finished, turn the device off\n            self._output_device.off()\n            self._running = False\n                \n    def _get_value(self):\n        try:\n            return next(self._gen)\n            \n        except StopIteration:\n            \n            self._n = self._n - 1 if self._n is not None else None\n            if self._n == 0:\n                # it's the end, return None\n                return None\n            else:\n                # recreate the generator and start again\n                self._gen = self._generator()\n                return next(self._gen)\n        \n    def stop(self):\n        \"\"\"\n        Stops the ValueChange object running.\n        \"\"\"\n        self._running = False\n        self._timer.deinit()\n\n###############################################################################\n# OUTPUT DEVICES\n###############################################################################\n\nclass OutputDevice:\n    \"\"\"\n    Base class for output devices. \n    \"\"\"   \n    def __init__(self, active_high=True, initial_value=False):\n        self.active_high = active_high\n        if initial_value is not None:\n            self._write(initial_value)\n        self._value_changer = None\n    \n    @property\n    def active_high(self):\n        \"\"\"\n        Sets or returns the active_high property. If :data:`True`, the \n        :meth:`on` method will set the Pin to HIGH. If :data:`False`, \n        the :meth:`on` method will set the Pin to LOW (the :meth:`off` method \n        always does the opposite).\n        \"\"\"\n        return self._active_state\n\n    @active_high.setter\n    def active_high(self, value):\n        self._active_state = True if value else False\n        self._inactive_state = False if value else True\n        \n    @property\n    def value(self):\n        \"\"\"\n        Sets or returns a value representing the state of the device: 1 is on, 0 is off.\n        \"\"\"\n        return self._read()\n\n    @value.setter\n    def value(self, value):\n        self._stop_change()\n        self._write(value)\n        \n    def on(self, value=1, t=None, wait=False):\n        \"\"\"\n        Turns the device on.\n\n        :param float value:\n            The value to set when turning on. Defaults to 1.\n\n        :param float t:\n            The time in seconds that the device should be on. If None is \n            specified, the device will stay on. The default is None.\n\n        :param bool wait:\n           If True, the method will block until the time `t` has expired. \n           If False, the method will return and the device will turn on in\n           the background. Defaults to False. Only effective if `t` is not\n           None.\n        \"\"\"\n        if t is None:\n            self.value = value\n        else:\n            self._start_change(lambda : iter([(value, t), ]), 1, wait)\n\n    def off(self):\n        \"\"\"\n        Turns the device off.\n        \"\"\"\n        self.value = 0\n            \n    @property\n    def is_active(self):\n        \"\"\"\n        Returns :data:`True` if the device is on.\n        \"\"\"\n        return bool(self.value)\n\n    def toggle(self):\n        \"\"\"\n        If the device is off, turn it on. If it is on, turn it off.\n        \"\"\"\n        if self.is_active:\n            self.off()\n        else:\n            self.on()\n            \n    def blink(self, on_time=1, off_time=None, n=None, wait=False):\n        \"\"\"\n        Makes the device turn on and off repeatedly.\n        \n        :param float on_time:\n            The length of time in seconds that the device will be on. Defaults to 1.\n\n        :param float off_time:\n            The length of time in seconds that the device will be off. If `None`, \n            it will be the same as ``on_time``. Defaults to `None`.\n\n        :param int n:\n            The number of times to repeat the blink operation. If None is \n            specified, the device will continue blinking forever. The default\n            is None.\n\n        :param bool wait:\n           If True, the method will block until the device stops turning on and off. \n           If False, the method will return and the device will turn on and off in\n           the background. Defaults to False.        \n        \"\"\"\n        off_time = on_time if off_time is None else off_time\n        \n        self.off()\n\n        # is there anything to change?\n        if on_time > 0 or off_time > 0:\n            self._start_change(lambda : iter([(1,on_time), (0,off_time)]), n, wait)\n            \n    def _start_change(self, generator, n, wait):\n        self._value_changer = ValueChange(self, generator, n, wait)\n    \n    def _stop_change(self):\n        if self._value_changer is not None:\n            self._value_changer.stop()\n            self._value_changer = None\n\n    def close(self):\n        \"\"\"\n        Turns the device off.\n        \"\"\"\n        self.value = 0\n\nclass DigitalOutputDevice(OutputDevice, PinMixin):\n    \"\"\"\n    Represents a device driven by a digital pin.\n\n    :param int pin:\n        The pin that the device is connected to.\n\n    :param bool active_high:\n        If :data:`True` (the default), the :meth:`on` method will set the Pin\n        to HIGH. If :data:`False`, the :meth:`on` method will set the Pin to\n        LOW (the :meth:`off` method always does the opposite).\n\n    :param bool initial_value:\n        If :data:`False` (the default), the LED will be off initially. If\n        :data:`True`, the LED will be switched on initially.\n    \"\"\"\n    def __init__(self, pin, active_high=True, initial_value=False):\n        self._pin_num = pin\n        self._pin = Pin(pin, Pin.OUT)\n        super().__init__(active_high, initial_value)\n        \n    def _value_to_state(self, value):\n        return int(self._active_state if value else self._inactive_state)\n    \n    def _state_to_value(self, state):\n        return int(bool(state) == self._active_state)\n    \n    def _read(self):\n        return self._state_to_value(self._pin.value())\n\n    def _write(self, value):\n        self._pin.value(self._value_to_state(value))\n                \n    def close(self):\n        \"\"\"\n        Closes the device and turns the device off. Once closed, the device\n        can no longer be used.\n        \"\"\"\n        super().close()\n        self._pin = None\n\nclass DigitalLED(DigitalOutputDevice):\n    \"\"\"\n    Represents a simple LED, which can be switched on and off.\n\n    :param int pin:\n        The pin that the device is connected to.\n\n    :param bool active_high:\n        If :data:`True` (the default), the :meth:`on` method will set the Pin\n        to HIGH. If :data:`False`, the :meth:`on` method will set the Pin to\n        LOW (the :meth:`off` method always does the opposite).\n\n    :param bool initial_value:\n        If :data:`False` (the default), the LED will be off initially. If\n        :data:`True`, the LED will be switched on initially.\n    \"\"\"\n    pass\n\nDigitalLED.is_lit = DigitalLED.is_active\n\nclass Buzzer(DigitalOutputDevice):\n    \"\"\"\n    Represents an active or passive buzzer, which can be turned on or off.\n\n    :param int pin:\n        The pin that the device is connected to.\n\n    :param bool active_high:\n        If :data:`True` (the default), the :meth:`on` method will set the Pin\n        to HIGH. If :data:`False`, the :meth:`on` method will set the Pin to\n        LOW (the :meth:`off` method always does the opposite).\n\n    :param bool initial_value:\n        If :data:`False` (the default), the Buzzer will be off initially. If\n        :data:`True`, the Buzzer will be switched on initially.\n    \"\"\"\n    pass\n\nBuzzer.beep = Buzzer.blink\n\nclass PWMOutputDevice(OutputDevice, PinMixin):\n    \"\"\"\n    Represents a device driven by a PWM pin.\n\n    :param int pin:\n        The pin that the device is connected to.\n\n    :param int freq:\n        The frequency of the PWM signal in hertz. Defaults to 100.\n\n    :param int duty_factor:\n        The duty factor of the PWM signal. This is a value between 0 and 65535.\n        Defaults to 65535.\n\n    :param bool active_high:\n        If :data:`True` (the default), the :meth:`on` method will set the Pin\n        to HIGH. If :data:`False`, the :meth:`on` method will set the Pin to\n        LOW (the :meth:`off` method always does the opposite).\n\n    :param bool initial_value:\n        If :data:`False` (the default), the LED will be off initially. If\n        :data:`True`, the LED will be switched on initially.\n    \"\"\"\n    \n    PIN_TO_PWM_CHANNEL = [\"0A\",\"0B\",\"1A\",\"1B\",\"2A\",\"2B\",\"3A\",\"3B\",\"4A\",\"4B\",\"5A\",\"5B\",\"6A\",\"6B\",\"7A\",\"7B\",\"0A\",\"0B\",\"1A\",\"1B\",\"2A\",\"2B\",\"3A\",\"3B\",\"4A\",\"4B\",\"5A\",\"5B\",\"6A\",\"6B\"]\n    _channels_used = {}\n    \n    def __init__(self, pin, freq=100, duty_factor=65535, active_high=True, initial_value=False):\n        self._check_pwm_channel(pin)\n        self._pin_num = pin\n        self._duty_factor = duty_factor\n        self._pwm = PWM(Pin(pin))\n        self._pwm.freq(freq)\n        super().__init__(active_high, initial_value)\n        \n    def _check_pwm_channel(self, pin_num):\n        channel = PWMOutputDevice.PIN_TO_PWM_CHANNEL[pin_num]\n        if channel in PWMOutputDevice._channels_used.keys():\n            raise PWMChannelAlreadyInUse(\n                \"PWM channel {} is already in use by {}. Use a different pin\".format(\n                    channel,\n                    str(PWMOutputDevice._channels_used[channel])\n                    )\n                )\n        else:\n            PWMOutputDevice._channels_used[channel] = self\n        \n    def _state_to_value(self, state):\n        return (state if self.active_high else self._duty_factor - state) / self._duty_factor\n\n    def _value_to_state(self, value):\n        return int(self._duty_factor * (value if self.active_high else 1 - value))\n    \n    def _read(self):\n        return self._state_to_value(self._pwm.duty_u16())\n    \n    def _write(self, value):\n        self._pwm.duty_u16(self._value_to_state(value))\n        \n    @property\n    def is_active(self):\n        \"\"\"\n        Returns :data:`True` if the device is on.\n        \"\"\"\n        return self.value != 0\n\n    @property\n    def freq(self):\n        \"\"\"\n        Returns the current frequency of the device.\n        \"\"\"\n        return self._pwm.freq()\n    \n    @freq.setter\n    def freq(self, freq):\n        \"\"\"\n        Sets the frequency of the device.\n        \"\"\"\n        self._pwm.freq(freq)\n\n    def blink(self, on_time=1, off_time=None, n=None, wait=False, fade_in_time=0, fade_out_time=None, fps=25):\n        \"\"\"\n        Makes the device turn on and off repeatedly.\n        \n        :param float on_time:\n            The length of time in seconds the device will be on. Defaults to 1.\n\n        :param float off_time:\n            The length of time in seconds the device will be off. If `None`, \n            it will be the same as ``on_time``. Defaults to `None`.\n\n        :param int n:\n            The number of times to repeat the blink operation. If `None`, the \n            device will continue blinking forever. The default is `None`.\n\n        :param bool wait:\n           If True, the method will block until the LED stops blinking. If False,\n           the method will return and the LED will blink in the background.\n           Defaults to False.\n\n        :param float fade_in_time:\n            The length of time in seconds to spend fading in. Defaults to 0.\n\n        :param float fade_out_time:\n            The length of time in seconds to spend fading out. If `None`,\n            it will be the same as ``fade_in_time``. Defaults to `None`.\n\n        :param int fps:\n           The frames per second that will be used to calculate the number of\n           steps between off/on states when fading. Defaults to 25.\n        \"\"\"\n        self.off()\n        \n        off_time = on_time if off_time is None else off_time\n        fade_out_time = fade_in_time if fade_out_time is None else fade_out_time\n        \n        def blink_generator():\n            if fade_in_time > 0:\n                for s in [\n                    (i * (1 / fps) / fade_in_time, 1 / fps)\n                    for i in range(int(fps * fade_in_time))\n                    ]:\n                    yield s\n            \n            if on_time > 0:\n                yield (1, on_time)\n\n            if fade_out_time > 0:\n                for s in [\n                    (1 - (i * (1 / fps) / fade_out_time), 1 / fps)\n                    for i in range(int(fps * fade_out_time))\n                    ]:\n                    yield s\n            \n            if off_time > 0:\n                yield (0, off_time)\n        \n        # is there anything to change?\n        if on_time > 0 or off_time > 0 or fade_in_time > 0 or fade_out_time > 0:\n            self._start_change(blink_generator, n, wait)\n\n    def pulse(self, fade_in_time=1, fade_out_time=None, n=None, wait=False, fps=25):\n        \"\"\"\n        Makes the device pulse on and off repeatedly.\n        \n        :param float fade_in_time:\n            The length of time in seconds that the device will take to turn on.\n            Defaults to 1.\n\n        :param float fade_out_time:\n           The length of time in seconds that the device will take to turn off.\n           Defaults to 1.\n           \n        :param int fps:\n           The frames per second that will be used to calculate the number of\n           steps between off/on states. Defaults to 25.\n           \n        :param int n:\n           The number of times to pulse the LED. If None, the LED will pulse\n           forever. Defaults to None.\n    \n        :param bool wait:\n           If True, the method will block until the LED stops pulsing. If False,\n           the method will return and the LED will pulse in the background.\n           Defaults to False.\n        \"\"\"\n        self.blink(on_time=0, off_time=0, fade_in_time=fade_in_time, fade_out_time=fade_out_time, n=n, wait=wait, fps=fps)\n\n    def close(self):\n        \"\"\"\n        Closes the device and turns the device off. Once closed, the device\n        can no longer be used.\n        \"\"\"\n        super().close()\n        del PWMOutputDevice._channels_used[\n            PWMOutputDevice.PIN_TO_PWM_CHANNEL[self._pin_num]\n            ]\n        self._pwm.deinit()\n        self._pwm = None\n    \nclass PWMLED(PWMOutputDevice):\n    \"\"\"\n    Represents an LED driven by a PWM pin; the brightness of the LED can be changed.\n\n    :param int pin:\n        The pin that the device is connected to.\n\n    :param int freq:\n        The frequency of the PWM signal in hertz. Defaults to 100.\n\n    :param int duty_factor:\n        The duty factor of the PWM signal. This is a value between 0 and 65535.\n        Defaults to 65535.\n\n    :param bool active_high:\n        If :data:`True` (the default), the :meth:`on` method will set the Pin\n        to HIGH. If :data:`False`, the :meth:`on` method will set the Pin to\n        LOW (the :meth:`off` method always does the opposite).\n\n    :param bool initial_value:\n        If :data:`False` (the default), the LED will be off initially. If\n        :data:`True`, the LED will be switched on initially.\n    \"\"\"\nPWMLED.brightness = PWMLED.value\n\ndef LED(pin, pwm=True, active_high=True, initial_value=False):\n    \"\"\"\n    Returns an instance of :class:`DigitalLED` or :class:`PWMLED` depending on\n    the value of the `pwm` parameter. \n\n    ::\n\n        from picozero import LED\n\n        my_pwm_led = LED(1)\n\n        my_digital_led = LED(2, pwm=False)\n\n    :param int pin:\n        The pin that the device is connected to.\n\n    :param int pin:\n        If `pwm` is :data:`True` (the default), a :class:`PWMLED` will be\n        returned. If `pwm` is :data:`False`, a :class:`DigitalLED` will be\n        returned. A :class:`PWMLED` can control the brightness of the LED but\n        uses 1 PWM channel.\n\n    :param bool active_high:\n        If :data:`True` (the default), the :meth:`on` method will set the Pin\n        to HIGH. If :data:`False`, the :meth:`on` method will set the Pin to\n        LOW (the :meth:`off` method always does the opposite).\n\n    :param bool initial_value:\n        If :data:`False` (the default), the device will be off initially. If\n        :data:`True`, the device will be switched on initially.\n    \"\"\"\n    if pwm:\n        return PWMLED(\n            pin=pin,\n            active_high=active_high,\n            initial_value=initial_value)\n    else:\n        return DigitalLED(\n            pin=pin,\n            active_high=active_high,\n            initial_value=initial_value)\n\ntry:\n    pico_led = LED(\"LED\", pwm=False)\nexcept TypeError:\n    # older version of micropython before \"LED\" was supported\n    pico_led = LED(25, pwm=False)\n\nclass PWMBuzzer(PWMOutputDevice):\n    \"\"\"\n    Represents a passive buzzer driven by a PWM pin; the volume of the buzzer can be changed.\n\n    :param int pin:\n        The pin that the buzzer is connected to.\n\n    :param int freq:\n        The frequency of the PWM signal in hertz. Defaults to 440.\n\n    :param int duty_factor:\n        The duty factor of the PWM signal. This is a value between 0 and 65535.\n        Defaults to 1023.\n\n    :param bool active_high:\n        If :data:`True` (the default), the :meth:`on` method will set the Pin\n        to HIGH. If :data:`False`, the :meth:`on` method will set the Pin to\n        LOW (the :meth:`off` method always does the opposite).\n\n    :param bool initial_value:\n        If :data:`False` (the default), the buzzer will be off initially.  If\n        :data:`True`, the buzzer will be switched on initially.\n    \"\"\"    \n    def __init__(self, pin, freq=440, duty_factor=1023, active_high=True, initial_value=False):\n        super().__init__(pin, freq, duty_factor, active_high, initial_value)\n\nPWMBuzzer.volume = PWMBuzzer.value\nPWMBuzzer.beep = PWMBuzzer.blink\n\nclass Speaker(OutputDevice, PinMixin):\n    \"\"\"\n    Represents a speaker driven by a PWM pin.\n\n    :param int pin:\n        The pin that the speaker is connected to.\n\n    :param int initial_freq:\n        The initial frequency of the PWM signal in hertz. Defaults to 440.\n    \n    :param int initial_volume:\n        The initial volume of the PWM signal. This is a value between 0 and\n        1. Defaults to 0.\n\n    :param int duty_factor:\n        The duty factor of the PWM signal. This is a value between 0 and 65535.\n        Defaults to 1023.\n\n    :param bool active_high:\n        If :data:`True` (the default), the :meth:`on` method will set the Pin\n        to HIGH. If :data:`False`, the :meth:`on` method will set the Pin to\n        LOW (the :meth:`off` method always does the opposite).\n    \"\"\"    \n    NOTES = {\n        'b0': 31, 'c1': 33, 'c#1': 35, 'd1': 37, 'd#1': 39, 'e1': 41, 'f1': 44, 'f#1': 46, 'g1': 49,'g#1': 52, 'a1': 55,\n        'a#1': 58, 'b1': 62, 'c2': 65, 'c#2': 69, 'd2': 73, 'd#2': 78,\n        'e2': 82, 'f2': 87, 'f#2': 93, 'g2': 98, 'g#2': 104, 'a2': 110, 'a#2': 117, 'b2': 123,\n        'c3': 131, 'c#3': 139, 'd3': 147, 'd#3': 156, 'e3': 165, 'f3': 175, 'f#3': 185, 'g3': 196, 'g#3': 208, 'a3': 220, 'a#3': 233, 'b3': 247,\n        'c4': 262, 'c#4': 277, 'd4': 294, 'd#4': 311, 'e4': 330, 'f4': 349, 'f#4': 370, 'g4': 392, 'g#4': 415, 'a4': 440, 'a#4': 466, 'b4': 494,\n        'c5': 523, 'c#5': 554, 'd5': 587, 'd#5': 622, 'e5': 659, 'f5': 698, 'f#5': 740, 'g5': 784, 'g#5': 831, 'a5': 880, 'a#5': 932, 'b5': 988,\n        'c6': 1047, 'c#6': 1109, 'd6': 1175, 'd#6': 1245, 'e6': 1319, 'f6': 1397, 'f#6': 1480, 'g6': 1568, 'g#6': 1661, 'a6': 1760, 'a#6': 1865, 'b6': 1976,\n        'c7': 2093, 'c#7': 2217, 'd7': 2349, 'd#7': 2489,\n        'e7': 2637, 'f7': 2794, 'f#7': 2960, 'g7': 3136, 'g#7': 3322, 'a7': 3520, 'a#7': 3729, 'b7': 3951,\n        'c8': 4186, 'c#8': 4435, 'd8': 4699, 'd#8': 4978 \n        }\n    \n    def __init__(self, pin, initial_freq=440, initial_volume=0, duty_factor=1023, active_high=True):\n        \n        self._pin_num = pin\n        self._pwm_buzzer = PWMBuzzer(\n            pin,\n            freq=initial_freq,\n            duty_factor=duty_factor,\n            active_high=active_high,\n            initial_value=None,\n            )\n        \n        super().__init__(active_high, None)\n        self.volume = initial_volume\n        \n    def on(self, volume=1):\n        self.volume = volume\n        \n    def off(self):\n        self.volume = 0\n\n    @property\n    def value(self):\n        \"\"\"\n        Sets or returns the value of the speaker. The value is a tuple of (freq, volume).\n        \"\"\"\n        return tuple(self.freq, self.volume)\n\n    @value.setter\n    def value(self, value):\n        self._stop_change()\n        self._write(value)\n\n    @property\n    def volume(self):\n        \"\"\"\n        Sets or returns the volume of the speaker: 1 for maximum volume, 0 for off.\n        \"\"\"\n        return self._volume\n\n    @volume.setter\n    def volume(self, value):\n        self._volume = value\n        self.value = (self.freq, self.volume)\n        \n    @property\n    def freq(self):\n        \"\"\"\n        Sets or returns the current frequency of the speaker.\n        \"\"\"\n        return self._pwm_buzzer.freq\n    \n    @freq.setter\n    def freq(self, freq):\n        self.value = (freq, self.volume)\n        \n    def _write(self, value):\n        # set the frequency\n        if value[0] is not None:\n            self._pwm_buzzer.freq = value[0]\n        \n        # write the volume value\n        if value[1] is not None:\n            self._pwm_buzzer.volume = value[1]\n\n    def _to_freq(self, freq):\n        if freq is not None and freq != '' and freq != 0: \n            if type(freq) is str:\n                return int(self.NOTES[freq])\n            elif freq <= 128 and freq > 0: # MIDI\n                midi_factor = 2**(1/12)\n                return int(440 * midi_factor ** (freq - 69))\n            else:\n                return freq\n        else:\n            return None\n\n    def beep(self, on_time=1, off_time=None, n=None, wait=False, fade_in_time=0, fade_out_time=None, fps=25):\n        \"\"\"\n        Makes the buzzer turn on and off repeatedly.\n        \n        :param float on_time:\n            The length of time in seconds that the device will be on. Defaults to 1.\n\n        :param float off_time:\n            The length of time in seconds that the device will be off. If `None`, \n            it will be the same as ``on_time``. Defaults to `None`.\n\n        :param int n:\n            The number of times to repeat the beep operation. If `None`, the \n            device will continue beeping forever. The default is `None`.\n\n        :param bool wait:\n           If True, the method will block until the buzzer stops beeping. If False,\n           the method will return and the buzzer will beep in the background.\n           Defaults to False.\n\n        :param float fade_in_time:\n            The length of time in seconds to spend fading in. Defaults to 0.\n\n        :param float fade_out_time:\n            The length of time in seconds to spend fading out. If `None`,\n            it will be the same as ``fade_in_time``. Defaults to `None`.\n\n        :param int fps:\n           The frames per second that will be used to calculate the number of\n           steps between off/on states when fading. Defaults to 25.\n        \"\"\"\n        self._pwm_buzzer.blink(on_time, off_time, n, wait, fade_in_time, fade_out_time, fps)\n\n    def play(self, tune=440, duration=1, volume=1, n=1, wait=True):\n        \"\"\"\n        Plays a tune for a given duration. \n\n        :param int tune:\n\n            The tune to play can be specified as:\n\n                + a single \"note\", represented as:\n                  + a frequency in Hz e.g. `440`\n                  + a midi note e.g. `60`\n                  + a note name as a string e.g. `\"E4\"`\n                + a list of notes and duration e.g. `[440, 1]` or `[\"E4\", 2]`\n                + a list of two value tuples of (note, duration) e.g. `[(440,1), (60, 2), (\"e4\", 3)]`\n\n            Defaults to `440`.\n        \n        :param int volume:\n            The volume of the tune; 1 is maximum volume, 0 is mute. Defaults to 1.\n\n        :param float duration:\n            The duration of each note in seconds. Defaults to 1.\n\n        :param int n:\n           The number of times to play the tune. If None, the tune will play\n           forever. Defaults to 1.\n    \n        :param bool wait:\n           If True, the method will block until the tune has finished. If False,\n           the method will return and the tune will play in the background.\n           Defaults to True.\n        \"\"\"\n\n        self.off()\n\n        # tune isn't a list, so it must be a single frequency or note\n        if not isinstance(tune, (list, tuple)):\n            tune = [(tune, duration)]\n        # if the first element isn't a list, then it must be list of a single note and duration\n        elif not isinstance(tune[0], (list, tuple)):\n            tune = [tune]\n\n        def tune_generator():\n            for note in tune:\n                \n                # note isn't a list or tuple, it must be a single frequency or note\n                if not isinstance(note, (list, tuple)):\n                    # make it into a tuple\n                    note = (note, duration)\n\n                # turn the notes into frequencies\n                freq = self._to_freq(note[0])\n                freq_duration = note[1]\n                freq_volume = volume if freq is not None else 0\n                \n                # if this is a tune of greater than 1 note, add gaps between notes\n                if len(tune) == 1:\n                    yield ((freq, freq_volume), freq_duration)\n                else:\n                    yield ((freq, freq_volume), freq_duration * 0.9)\n                    yield ((freq, 0), freq_duration * 0.1)\n                    \n        self._start_change(tune_generator, n, wait)\n\n    def close(self):\n        self._pwm_buzzer.close()\n\nclass RGBLED(OutputDevice, PinsMixin):\n    \"\"\"\n    Extends :class:`OutputDevice` and represents a full colour LED component (composed\n    of red, green, and blue LEDs).\n    Connect the common cathode (longest leg) to a ground pin; connect each of\n    the other legs (representing the red, green, and blue anodes) to any GP\n    pins. You should use three limiting resistors (one per anode).\n    The following code will make the LED yellow::\n\n        from picozero import RGBLED\n        rgb = RGBLED(1, 2, 3)\n        rgb.color = (1, 1, 0)\n\n    0â€“255 colours are also supported::\n\n        rgb.color = (255, 255, 0)\n\n    :type red: int\n    :param red:\n        The GP pin that controls the red component of the RGB LED. \n    :type green: int\n    :param green:\n        The GP pin that controls the green component of the RGB LED.\n    :type blue: int\n    :param blue:\n        The GP pin that controls the blue component of the RGB LED.\n    :param bool active_high:\n        Set to :data:`True` (the default) for common cathode RGB LEDs. If you\n        are using a common anode RGB LED, set this to :data:`False`.\n    :type initial_value: ~colorzero.Color or tuple\n    :param initial_value:\n        The initial color for the RGB LED. Defaults to black ``(0, 0, 0)``.\n    :param bool pwm:\n        If :data:`True` (the default), construct :class:`PWMLED` instances for\n        each component of the RGBLED. If :data:`False`, construct \n        :class:`DigitalLED` instances.\n    \n    \"\"\"\n    def __init__(self, red=None, green=None, blue=None, active_high=True,\n                 initial_value=(0, 0, 0), pwm=True):\n        self._pin_nums = (red, green, blue)\n        self._leds = ()\n        self._last = initial_value\n        LEDClass = PWMLED if pwm else DigitalLED\n        self._leds = tuple(\n            LEDClass(pin, active_high=active_high)\n            for pin in (red, green, blue))\n        super().__init__(active_high, initial_value)\n        \n    def _write(self, value):\n        if type(value) is not tuple:\n            value = (value, ) * 3       \n        for led, v in zip(self._leds, value):\n            led.value = v\n        \n    @property\n    def value(self):\n        \"\"\"\n        Represents the colour of the LED as an RGB 3-tuple of ``(red, green,\n        blue)`` where each value is between 0 and 1 if *pwm* was :data:`True`\n        when the class was constructed (but only takes values of 0 or 1 otherwise).\n        For example, red would be ``(1, 0, 0)`` and yellow would be ``(1, 1,\n        0)``, whereas orange would be ``(1, 0.5, 0)``.\n        \"\"\"\n        return tuple(led.value for led in self._leds)\n\n    @value.setter\n    def value(self, value):\n        self._stop_change()\n        self._write(value)\n\n    @property\n    def is_active(self):\n        \"\"\"\n        Returns :data:`True` if the LED is currently active (not black) and\n        :data:`False` otherwise.\n        \"\"\"\n        return self.value != (0, 0, 0)\n\n    is_lit = is_active\n\n    def _to_255(self, value):\n        return round(value * 255)\n    \n    def _from_255(self, value):\n        return 0 if value == 0 else value / 255\n    \n    @property\n    def color(self):\n        \"\"\"\n        Represents the colour of the LED as an RGB 3-tuple of ``(red, green,\n        blue)`` where each value is between 0 and 255 if *pwm* was :data:`True`\n        when the class was constructed (but only takes values of 0 or 255 otherwise).\n        For example, red would be ``(255, 0, 0)`` and yellow would be ``(255, 255,\n        0)``, whereas orange would be ``(255, 127, 0)``.\n        \"\"\"\n        return tuple(self._to_255(v) for v in self.value)\n\n    @color.setter\n    def color(self, value):\n        self.value = tuple(self._from_255(v) for v in value)\n\n    @property\n    def red(self):\n        \"\"\"\n        Represents the red component of the LED as a value between 0 and 255 if *pwm* was :data:`True`\n        when the class was constructed (but only takes values of 0 or 255 otherwise).\n        \"\"\"\n        return self._to_255(self.value[0])\n\n    @red.setter\n    def red(self, value):\n        r, g, b = self.value\n        self.value = self._from_255(value), g, b\n\n    @property\n    def green(self):\n        \"\"\"\n        Represents the green component of the LED as a value between 0 and 255 if *pwm* was :data:`True`\n        when the class was constructed (but only takes values of 0 or 255 otherwise).\n        \"\"\"\n        return self._to_255(self.value[1])\n\n    @green.setter\n    def green(self, value):\n        r, g, b = self.value\n        self.value = r, self._from_255(value), b\n\n    @property\n    def blue(self):\n        \"\"\"\n        Represents the blue component of the LED as a value between 0 and 255 if *pwm* was :data:`True`\n        when the class was constructed (but only takes values of 0 or 255 otherwise).\n        \"\"\"\n        return self._to_255(self.value[2])\n\n    @blue.setter\n    def blue(self, value):\n        r, g, b = self.value\n        self.value = r, g, self._from_255(value)\n\n    def on(self):\n        \"\"\"\n        Turns the LED on. This is equivalent to setting the LED color to white, e.g.\n        ``(1, 1, 1)``.\n        \"\"\"\n        self.value = (1, 1, 1)\n\n    def invert(self):\n        \"\"\"\n        Inverts the state of the device. If the device is currently off\n        (:attr:`value` is ``(0, 0, 0)``), this changes it to \"fully\" on\n        (:attr:`value` is ``(1, 1, 1)``). If the device has a specific colour,\n        this method inverts the colour.\n        \"\"\"\n        r, g, b = self.value\n        self.value = (1 - r, 1 - g, 1 - b)\n        \n    def toggle(self):\n        \"\"\"\n        Toggles the state of the device. If the device has a specific colour, then that colour is saved and the device is turned off. \n        If the device is off, it will be changed to the last colour it had when it was on or, if none, to fully on (:attr:`value` is ``(1, 1, 1)``).\n        \"\"\"\n        if self.value == (0, 0, 0):\n            self.value = self._last or (1, 1, 1)\n        else:\n            self._last = self.value \n            self.value = (0, 0, 0)\n            \n    def blink(self, on_times=1, fade_times=0, colors=((1, 0, 0), (0, 1, 0), (0, 0, 1)), n=None, wait=False, fps=25):\n        \"\"\"\n        Makes the device blink between colours repeatedly.\n\n        :param float on_times:\n            Single value or tuple of numbers of seconds to stay on each colour. Defaults to 1 second. \n        :param float fade_times:\n            Single value or tuple of times to fade between each colour. Must be 0 if\n            *pwm* was :data:`False` when the class was constructed.\n        :type colors: tuple\n            Tuple of colours to blink between, use ``(0, 0, 0)`` for off.\n        :param colors:\n            The colours to blink between. Defaults to red, green, blue.\n        :type n: int or None\n        :param n:\n            Number of times to blink; :data:`None` (the default) means forever.\n        :param bool wait:\n            If :data:`False` (the default), use a Timer to manage blinking,\n            continue blinking, and return immediately. If :data:`False`, only\n            return when the blinking is finished (warning: the default value of\n            *n* will result in this method never returning).\n        \"\"\"    \n        self.off()\n        \n        if type(on_times) is not tuple:\n            on_times = (on_times, ) * len(colors)\n        if type(fade_times) is not tuple:\n            fade_times = (fade_times, ) * len(colors)\n        # If any value is above zero then treat all as 0-255 values\n        if any(v > 1 for v in sum(colors, ())):\n            colors = tuple(tuple(self._from_255(v) for v in t) for t in colors)\n        \n        def blink_generator():\n        \n            # Define a linear interpolation between\n            # off_color and on_color\n            \n            lerp = lambda t, fade_in, color1, color2: tuple(\n                (1 - t) * off + t * on\n                if fade_in else\n                (1 - t) * on + t * off\n                for off, on in zip(color2, color1)\n                )\n            \n            for c in range(len(colors)):\n                if on_times[c] > 0:\n                    yield (colors[c], on_times[c])\n                    \n                if fade_times[c] > 0:\n                    for i in range(int(fps * fade_times[c])):\n                        v = lerp(i * (1 / fps) / fade_times[c], True, colors[(c + 1) % len(colors)], colors[c])\n                        t = 1 / fps       \n                        yield (v, t)\n    \n        self._start_change(blink_generator, n, wait)\n            \n    def pulse(self, fade_times=1, colors=((0, 0, 0), (1, 0, 0), (0, 0, 0), (0, 1, 0), (0, 0, 0), (0, 0, 1)), n=None, wait=False, fps=25):\n        \"\"\"\n        Makes the device fade between colours repeatedly.\n\n        :param float fade_times:\n            Single value or tuple of numbers of seconds to spend fading. Defaults to 1.\n        :param float fade_out_time:\n            Number of seconds to spend fading out. Defaults to 1.\n        :type colors: tuple\n        :param on_color:\n            Tuple of colours to pulse between in order. Defaults to red, off, green, off, blue, off. \n        :type off_color: ~colorzero.Color or tuple\n        :type n: int or None\n        :param n:\n            Number of times to pulse; :data:`None` (the default) means forever.\n        \"\"\"\n        on_times = 0\n        self.blink(on_times, fade_times, colors, n, wait, fps)\n        \n    def cycle(self, fade_times=1, colors=((1, 0, 0), (0, 1, 0), (0, 0, 1)), n=None, wait=False, fps=25):\n        \"\"\"\n        Makes the device fade in and out repeatedly.\n\n        :param float fade_times:\n            Single value or tuple of numbers of seconds to spend fading between colours. Defaults to 1.\n        :param float fade_times:\n            Number of seconds to spend fading out. Defaults to 1.\n        :type colors: tuple\n        :param on_color:\n            Tuple of colours to cycle between. Defaults to red, green, blue. \n        :type n: int or None\n        :param n:\n            Number of times to cycle; :data:`None` (the default) means forever.\n        \"\"\"\n        on_times = 0\n        self.blink(on_times, fade_times, colors, n, wait, fps)\n\n    def close(self):\n        super().close()\n        for led in self._leds:\n            led.close()\n        self._leds = None\n    \nRGBLED.colour = RGBLED.color\n\nclass Motor(PinsMixin):\n    \"\"\"\n    Represents a motor connected to a motor controller that has a two-pin\n    input. One pin drives the motor \"forward\", the other drives the motor\n    \"backward\".\n\n    :type forward: int\n    :param forward:\n        The GP pin that controls the \"forward\" motion of the motor. \n    \n    :type backward: int\n    :param backward:\n        The GP pin that controls the \"backward\" motion of the motor. \n    \n    :param bool pwm:\n        If :data:`True` (the default), PWM pins are used to drive the motor. \n        When using PWM pins, values between 0 and 1 can be used to set the \n        speed.\n    \n    \"\"\"\n    def __init__(self, forward, backward, pwm=True):\n        self._pin_nums = (forward, backward)\n        self._forward = PWMOutputDevice(forward) if pwm else DigitalOutputDevice(forward)\n        self._backward = PWMOutputDevice(backward) if pwm else DigitalOutputDevice(backward)\n        \n    def on(self, speed=1, t=None, wait=False):\n        \"\"\"\n        Turns the motor on and makes it turn.\n\n        :param float speed:\n            The speed as a value between -1 and 1: 1 turns the motor at\n            full speed in one direction, -1 turns the motor at full speed in\n            the opposite direction. Defaults to 1.\n\n        :param float t:\n            The time in seconds that the motor should run for. If None is \n            specified, the motor will stay on. The default is None.\n\n        :param bool wait:\n           If True, the method will block until the time `t` has expired. \n           If False, the method will return and the motor will turn on in\n           the background. Defaults to False. Only effective if `t` is not\n           None.\n        \"\"\"\n        if speed > 0:\n            self._backward.off()\n            self._forward.on(speed, t, wait)\n            \n        elif speed < 0:\n            self._forward.off()\n            self._backward.on(-speed, t, wait)\n        \n        else:\n            self.off()\n\n    def off(self):\n        \"\"\"\n        Stops the motor turning.\n        \"\"\"\n        self._backward.off()\n        self._forward.off()\n\n    @property\n    def value(self):\n        \"\"\"\n        Sets or returns the motor speed as a value between -1 and 1: -1 is full\n        speed \"backward\", 1 is full speed \"forward\", 0 is stopped.\n        \"\"\"\n        return self._forward.value + (-self._backward.value)\n\n    @value.setter\n    def value(self, value):\n        if value != 0:\n            self.on(value)\n        else:\n            self.stop()\n\n    def forward(self, speed=1, t=None, wait=False):\n        \"\"\"\n        Makes the motor turn \"forward\".\n\n        :param float speed:\n            The speed as a value between 0 and 1: 1 is full speed, 0 is stop. Defaults to 1.\n\n        :param float t:\n            The time in seconds that the motor should turn for. If None is \n            specified, the motor will stay on. The default is None.\n\n        :param bool wait:\n           If True, the method will block until the time `t` has expired. \n           If False, the method will return and the motor will turn on in\n           the background. Defaults to False. Only effective if `t` is not\n           None.\n        \"\"\"\n        self.on(speed, t, wait)\n\n    def backward(self, speed=1, t=None, wait=False):\n        \"\"\"\n        Makes the motor turn \"backward\".\n\n        :param float speed:\n            The speed as a value between 0 and 1: 1 is full speed, 0 is stop. Defaults to 1.\n\n        :param float t:\n            The time in seconds that the motor should turn for. If None is \n            specified, the motor will stay on. The default is None.\n\n        :param bool wait:\n           If True, the method will block until the time `t` has expired. \n           If False, the method will return and the motor will turn on in\n           the background. Defaults to False. Only effective if `t` is not\n           None.\n        \"\"\"\n        self.on(-speed, t, wait)\n\n    def close(self):\n        \"\"\"\n        Closes the device and releases any resources. Once closed, the device\n        can no longer be used.\n        \"\"\"\n        self._forward.close()\n        self._backward.close()\n\nMotor.start = Motor.on\nMotor.stop = Motor.off\n\nclass Robot:\n    \"\"\"\n    Represents a generic dual-motor robot / rover / buggy.\n\n    Alias for :class:`Rover`.\n\n    This class is constructed with two tuples representing the forward and\n    backward pins of the left and right controllers. For example,\n    if the left motor's controller is connected to pins 12 and 13, while the\n    right motor's controller is connected to pins 14 and 15, then the following\n    example will drive the robot forward::\n\n        from picozero import Robot\n\n        robot = Robot(left=(12, 13), right=(14, 15))\n        robot.forward()\n\n    :param tuple left:\n        A tuple of two pins representing the forward and backward inputs of the \n        left motor's controller.\n\n    :param tuple right:\n        A tuple of two pins representing the forward and backward inputs of the \n        right motor's controller.\n\n    :param bool pwm:\n        If :data:`True` (the default), pwm pins will be used, allowing variable \n        speed control. \n\n    \"\"\"\n    def __init__(self, left, right, pwm=True):\n        self._left = Motor(left[0], left[1], pwm)\n        self._right = Motor(right[0], right[1], pwm)\n\n    @property\n    def left_motor(self):\n        \"\"\"\n        Returns the left :class:`Motor`.\n        \"\"\"\n        return self._left\n\n    @property\n    def right_motor(self):\n        \"\"\"\n        Returns the right :class:`Motor`.\n        \"\"\"\n        return self._right\n\n    @property\n    def value(self):\n        \"\"\"\n        Represents the motion of the robot as a tuple of (left_motor_speed,\n        right_motor_speed) with ``(-1, -1)`` representing full speed backwards,\n        ``(1, 1)`` representing full speed forwards, and ``(0, 0)``\n        representing stopped.\n        \"\"\"\n        return (self._left.value, self._right.value)\n\n    @value.setter\n    def value(self, value):\n        self._left.value, self._right.value = value\n        \n    def forward(self, speed=1, t=None, wait=False):\n        \"\"\"\n        Makes the robot move \"forward\".\n\n        :param float speed:\n            The speed as a value between 0 and 1: 1 is full speed, 0 is stop. Defaults to 1.\n\n        :param float t:\n            The time in seconds that the robot should move for. If None is \n            specified, the robot will continue to move until stopped. The default \n            is None.\n\n        :param bool wait:\n           If True, the method will block until the time `t` has expired. \n           If False, the method will return and the motor will turn on in\n           the background. Defaults to False. Only effective if `t` is not\n           None.\n        \"\"\"\n        self._left.forward(speed, t, False)\n        self._right.forward(speed, t, wait)\n        \n    def backward(self, speed=1, t=None, wait=False):\n        \"\"\"\n        Makes the robot move \"backward\".\n\n        :param float speed:\n            The speed as a value between 0 and 1: 1 is full speed, 0 is stop. Defaults to 1.\n\n        :param float t:\n            The time in seconds that the robot should move for. If None is \n            specified, the robot will continue to move until stopped. The default \n            is None.\n\n        :param bool wait:\n           If True, the method will block until the time `t` has expired. \n           If False, the method will return and the motor will turn on in\n           the background. Defaults to False. Only effective if `t` is not\n           None.\n        \"\"\"\n        self._left.backward(speed, t, False)\n        self._right.backward(speed, t, wait)\n        \n    def left(self, speed=1, t=None, wait=False):\n        \"\"\"\n        Makes the robot turn \"left\" by turning the left motor backward and the \n        right motor forward.\n\n        :param float speed:\n            The speed as a value between 0 and 1: 1 is full speed, 0 is stop. Defaults to 1.\n\n        :param float t:\n            The time in seconds that the robot should turn for. If None is \n            specified, the robot will continue to turn until stopped. The default \n            is None.\n\n        :param bool wait:\n           If True, the method will block until the time `t` has expired. \n           If False, the method will return and the motor will turn on in\n           the background. Defaults to False. Only effective if `t` is not\n           None.\n        \"\"\"\n        self._left.backward(speed, t, False)\n        self._right.forward(speed, t, wait)\n    \n    def right(self, speed=1, t=None, wait=False):\n        \"\"\"\n        Makes the robot turn \"right\" by turning the left motor forward and the \n        right motor backward.\n\n        :param float speed:\n            The speed as a value between 0 and 1: 1 is full speed, 0 is stop. Defaults to 1.\n\n        :param float t:\n            The time in seconds that the robot should turn for. If None is \n            specified, the robot will continue to turn until stopped. The default \n            is None.\n\n        :param bool wait:\n           If True, the method will block until the time `t` has expired. \n           If False, the method will return and the motor will turn on in\n           the background. Defaults to False. Only effective if `t` is not\n           None.\n        \"\"\"\n        self._left.forward(speed, t, False)\n        self._right.backward(speed, t, wait)\n        \n    def stop(self):\n        \"\"\"\n        Stops the robot.\n        \"\"\"\n        self._left.stop()\n        self._right.stop()\n\n    def close(self):\n        \"\"\"\n        Closes the device and releases any resources. Once closed, the device\n        can no longer be used.\n        \"\"\"\n        self._left.close()\n        self._right.close()\n    \nRover = Robot\n\nclass Servo(PWMOutputDevice):\n    \"\"\"\n    Represents a PWM-controlled servo motor.\n\n    Setting the `value` to 0 will move the servo to its minimum position,\n    1 will move the servo to its maximum position. Setting the `value` to\n    :data:`None` will turn the servo \"off\" (i.e. no signal is sent).\n\n    :type pin: int\n    :param pin:\n        The pin the servo motor is connected to. \n\n    :param bool initial_value:\n        If :data:`0`, the servo will be set to its minimum position.  If\n        :data:`1`, the servo will set to its maximum position. If :data:`None`\n        (the default), the position of the servo will not change.\n\n    :param float min_pulse_width:\n        The pulse width corresponding to the servo's minimum position. This\n        defaults to 1ms.\n\n    :param float max_pulse_width:\n        The pulse width corresponding to the servo's maximum position. This\n        defaults to 2ms.\n\n    :param float frame_width:\n        The length of time between servo control pulses measured in seconds.\n        This defaults to 20ms which is a common value for servos.\n\n    :param int duty_factor:\n        The duty factor of the PWM signal. This is a value between 0 and 65535.\n        Defaults to 65535.    \n    \"\"\"\n    def __init__(self, pin, initial_value=None, min_pulse_width=1/1000, max_pulse_width=2/1000, frame_width=20/1000, duty_factor=65535):\n        self._min_duty = int((min_pulse_width / frame_width) * duty_factor)\n        self._max_duty = int((max_pulse_width / frame_width) * duty_factor)\n        \n        super().__init__(pin, freq=int(1 / frame_width), duty_factor=duty_factor, initial_value=initial_value)\n        \n    def _state_to_value(self, state):\n        return None if state == 0 else clamp((state - self._min_duty) / (self._max_duty - self._min_duty), 0, 1)\n        \n    def _value_to_state(self, value):\n        return 0 if value is None else int(self._min_duty + ((self._max_duty - self._min_duty) * value))\n    \n    def min(self):\n        \"\"\"\n        Set the servo to its minimum position.\n        \"\"\"\n        self.value = 0\n    \n    def mid(self):\n        \"\"\"\n        Set the servo to its mid-point position.\n        \"\"\"\n        self.value = 0.5\n        \n    def max(self):\n        \"\"\"\n        Set the servo to its maximum position.\n        \"\"\"\n        self.value = 1\n\n    def off(self):\n        \"\"\"\n        Turn the servo \"off\" by setting the value to `None`.\n        \"\"\"\n        self.value = None\n\n###############################################################################\n# INPUT DEVICES\n###############################################################################\n\nclass InputDevice:\n    \"\"\"\n    Base class for input devices.\n    \"\"\"\n    def __init__(self, active_state=None):\n        self._active_state = active_state\n\n    @property\n    def active_state(self):\n        \"\"\"\n        Sets or returns the active state of the device. If :data:`None` (the default),\n        the device will return the value that the pin is set to. If\n        :data:`True`, the device will return :data:`True` if the pin is\n        HIGH. If :data:`False`, the device will return :data:`False` if the\n        pin is LOW.\n        \"\"\"\n        return self._active_state\n\n    @active_state.setter\n    def active_state(self, value):\n        self._active_state = True if value else False\n        self._inactive_state = False if value else True\n        \n    @property\n    def value(self):\n        \"\"\"\n        Returns the current value of the device. This is either :data:`True` \n        or :data:`False` depending on the value of :attr:`active_state`.\n        \"\"\"\n        return self._read()\n\nclass DigitalInputDevice(InputDevice, PinMixin):\n    \"\"\"\n    Represents a generic input device with digital functionality e.g. buttons \n    that can be either active or inactive.\n\n    :param int pin:\n        The pin that the device is connected to.\n\n    :param bool pull_up:\n        If :data:`True`, the device will be pulled up to HIGH. If\n        :data:`False` (the default), the device will be pulled down to LOW.\n\n    :param bool active_state:\n        If :data:`True` (the default), the device will return :data:`True`\n        if the pin is HIGH. If :data:`False`, the device will return\n        :data:`False` if the pin is LOW.\n\n    :param float bounce_time:\n        The bounce time for the device. If set, the device will ignore\n        any button presses that happen within the bounce time after a\n        button release. This is useful to prevent accidental button\n        presses from registering as multiple presses. The default is \n        :data:`None`.\n    \"\"\"\n    def __init__(self, pin, pull_up=False, active_state=None, bounce_time=None):\n        super().__init__(active_state)\n        self._pin_num = pin\n        self._pin = Pin(\n            pin,\n            mode=Pin.IN,\n            pull=Pin.PULL_UP if pull_up else Pin.PULL_DOWN)\n        self._bounce_time = bounce_time\n        \n        if active_state is None:\n            self._active_state = False if pull_up else True\n        else:\n            self._active_state = active_state\n        \n        self._state = self._pin.value()\n        \n        self._when_activated = None\n        self._when_deactivated = None\n        \n        # setup interupt\n        self._pin.irq(self._pin_change, Pin.IRQ_RISING | Pin.IRQ_FALLING)\n        \n    def _state_to_value(self, state):\n        return int(bool(state) == self._active_state)\n    \n    def _read(self):\n        return self._state_to_value(self._state)\n\n    def _pin_change(self, p):\n        # turn off the interupt\n        p.irq(handler=None)\n        \n        last_state = p.value()\n        \n        if self._bounce_time is not None:\n            # wait for stability\n            stop = ticks_ms() + (self._bounce_time * 1000)\n            while ticks_ms() < stop:\n                # keep checking, reset the stop if the value changes\n                if p.value() != last_state:\n                    stop = ticks_ms() + self._bounce_time\n                    last_state = p.value()\n        \n        # re-enable the interupt\n        p.irq(self._pin_change, Pin.IRQ_RISING | Pin.IRQ_FALLING)\n        \n        # did the value actually change? \n        if self._state != last_state:\n            # set the state\n            self._state = self._pin.value()\n            \n            # manage call backs\n            callback_to_run = None\n            if self.value and self._when_activated is not None:\n                callback_to_run = self._when_activated\n                    \n            elif not self.value and self._when_deactivated is not None:\n                callback_to_run = self._when_deactivated\n            \n            if callback_to_run is not None:\n                \n                def schedule_callback(callback):\n                    callback()\n            \n                try:\n                    schedule(schedule_callback, callback_to_run)\n                    \n                except RuntimeError as e:\n                    if str(e) == \"schedule queue full\":\n                        raise EventFailedScheduleQueueFull(\n                            \"{} - {} not run due to the micropython schedule being full\".format(\n                                str(self), callback_to_run.__name__))\n                    else:\n                        raise e\n\n    @property\n    def is_active(self):\n        \"\"\"\n        Returns :data:`True` if the device is active.\n        \"\"\"\n        return bool(self.value)\n\n    @property\n    def is_inactive(self):\n        \"\"\"\n        Returns :data:`True` if the device is inactive.\n        \"\"\"\n        return not bool(self.value)\n    \n    @property\n    def when_activated(self):\n        \"\"\"\n        Returns a :samp:`callback` that will be called when the device is activated.\n        \"\"\"\n        return self._when_activated\n    \n    @when_activated.setter\n    def when_activated(self, value):\n        self._when_activated = value\n        \n    @property\n    def when_deactivated(self):\n        \"\"\"\n        Returns a :samp:`callback` that will be called when the device is deactivated.\n        \"\"\"\n        return self._when_deactivated\n    \n    @when_deactivated.setter\n    def when_deactivated(self, value):\n        self._when_deactivated = value\n    \n    def close(self):\n        \"\"\"\n        Closes the device and releases any resources. Once closed, the device\n        can no longer be used.\n        \"\"\"\n        self._pin.irq(handler=None)\n        self._pin = None\n\nclass Switch(DigitalInputDevice):\n    \"\"\"\n    Represents a toggle switch, which is either open or closed.\n\n    :param int pin:\n        The pin that the device is connected to.\n\n    :param bool pull_up:\n        If :data:`True` (the default), the device will be pulled up to\n        HIGH. If :data:`False`, the device will be pulled down to LOW.\n\n    :param float bounce_time:\n        The bounce time for the device. If set, the device will ignore\n        any button presses that happen within the bounce time after a\n        button release. This is useful to prevent accidental button\n        presses from registering as multiple presses. Defaults to 0.02 \n        seconds.\n    \"\"\"\n    def __init__(self, pin, pull_up=True, bounce_time=0.02): \n        super().__init__(pin=pin, pull_up=pull_up, bounce_time=bounce_time)\n\nSwitch.is_closed = Switch.is_active\nSwitch.is_open = Switch.is_inactive\nSwitch.when_closed = Switch.when_activated\nSwitch.when_opened = Switch.when_deactivated\n\nclass Button(Switch):\n    \"\"\"\n    Represents a push button, which can be either pressed or released.\n\n    :param int pin:\n        The pin that the device is connected to.\n\n    :param bool pull_up:\n        If :data:`True` (the default), the device will be pulled up to\n        HIGH. If :data:`False`, the device will be pulled down to LOW.\n\n    :param float bounce_time:\n        The bounce time for the device. If set, the device will ignore\n        any button presses that happen within the bounce time after a\n        button release. This is useful to prevent accidental button\n        presses from registering as multiple presses. Defaults to 0.02 \n        seconds.\n    \"\"\"\n    pass\n\nButton.is_pressed = Button.is_active\nButton.is_released = Button.is_inactive\nButton.when_pressed = Button.when_activated\nButton.when_released = Button.when_deactivated \n\nclass AnalogInputDevice(InputDevice, PinMixin):\n    \"\"\"\n    Represents a generic input device with analogue functionality, e.g. \n    a potentiometer.\n\n    :param int pin:\n        The pin that the device is connected to.\n        \n    :param active_state:\n        The active state of the device. If :data:`True` (the default),\n        the :class:`AnalogInputDevice` will assume that the device is\n        active when the pin is high and above the threshold. If \n        ``active_state`` is ``False``, the device will be active when \n        the pin is low and below the threshold. \n\n    :param float threshold:\n        The threshold that the device must be above or below to be\n        considered active. The default is 0.5.\n\n    \"\"\"\n    def __init__(self, pin, active_state=True, threshold=0.5):\n        self._pin_num = pin\n        super().__init__(active_state)\n        self._adc = ADC(pin)\n        self._threshold = float(threshold)\n        \n    def _state_to_value(self, state):\n        return (state if self.active_state else 65535 - state) / 65535\n\n    def _value_to_state(self, value):\n        return int(65535 * (value if self.active_state else 1 - value))\n    \n    def _read(self):\n        return self._state_to_value(self._adc.read_u16())\n        \n    @property\n    def threshold(self):\n        \"\"\"\n        The threshold that the device must be above or below to be\n        considered active. The default is 0.5.\n        \"\"\"\n        return self._threshold\n\n    @threshold.setter\n    def threshold(self, value):\n        self._threshold = float(value)\n\n    @property\n    def is_active(self):\n        \"\"\"\n        Returns :data:`True` if the device is active.\n        \"\"\"\n        return self.value > self.threshold\n\n    @property\n    def voltage(self):\n        \"\"\"\n        Returns the voltage of the analogue device.\n        \"\"\"\n        return self.value * 3.3\n\n    def close(self):\n        self._adc = None\n\nclass Potentiometer(AnalogInputDevice):\n    \"\"\"\n    Represents a potentiometer, which outputs a variable voltage\n    between 0 and 3.3V.\n\n    Alias for :class:`Pot`.\n\n    :param int pin:\n        The pin that the device is connected to.\n        \n    :param active_state:\n        The active state of the device. If :data:`True` (the default),\n        the :class:`AnalogInputDevice` will assume that the device is\n        active when the pin is high and above the threshold. If \n        ``active_state`` is ``False``, the device will be active when \n        the pin is low and below the threshold. \n\n    :param float threshold:\n        The threshold that the device must be above or below to be\n        considered active. The default is 0.5.\n\n    \"\"\"\n    pass\n\nPot = Potentiometer\n\ndef pico_temp_conversion(voltage):\n    # Formula for calculating temp from voltage for the onboard temperature sensor\n    return 27 - (voltage - 0.706)/0.001721\n\nclass TemperatureSensor(AnalogInputDevice):\n    \"\"\"\n    Represents a TemperatureSensor, which outputs a variable voltage. The voltage \n    can be converted to a temperature using a `conversion` function passed as a \n    parameter.\n\n    Alias for :class:`Thermistor` and :class:`TempSensor`.\n\n    :param int pin:\n        The pin that the device is connected to.\n        \n    :param active_state:\n        The active state of the device. If :data:`True` (the default),\n        the :class:`AnalogInputDevice` will assume that the device is\n        active when the pin is high and above the threshold. If \n        ``active_state`` is ``False``, the device will be active when \n        the pin is low and below the threshold. \n\n    :param float threshold:\n        The threshold that the device must be above or below to be\n        considered active. The default is 0.5.\n\n    :param float conversion:\n        A function that takes a voltage and returns a temperature. \n\n        e.g. The internal temperature sensor has a voltage range of 0.706V to 0.716V \n        and would use the follow conversion function::\n        \n            def temp_conversion(voltage):\n                return 27 - (voltage - 0.706)/0.001721\n\n            temp_sensor = TemperatureSensor(pin, conversion=temp_conversion)\n\n        If :data:`None` (the default), the ``temp`` property will return :data:`None`.\n\n    \"\"\"\n    def __init__(self, pin, active_state=True, threshold=0.5, conversion=None):\n         self._conversion = conversion\n         super().__init__(pin, active_state, threshold)\n        \n    @property\n    def temp(self):\n        \"\"\"\n        Returns the temperature of the device. If the conversion function is not\n        set, this will return :data:`None`.\n        \"\"\"\n        if self._conversion is not None:\n            return self._conversion(self.voltage)\n        else:\n            return None\n\n    @property\n    def conversion(self):\n        \"\"\"\n        Sets or returns the conversion function for the device.\n        \"\"\"\n        return self._conversion\n\n    @conversion.setter\n    def conversion(self, value):\n        self._conversion = value\n       \npico_temp_sensor = TemperatureSensor(4, True, 0.5, pico_temp_conversion)\nTempSensor = TemperatureSensor\nThermistor = TemperatureSensor\n\nclass DistanceSensor(PinsMixin):\n    \"\"\"\n    Represents a HC-SR04 ultrasonic distance sensor.\n\n    :param int echo:\n        The pin that the ECHO pin is connected to.\n\n    :param int trigger:\n        The pin that the TRIG pin is connected to. \n\n    :param float max_distance:\n        The :attr:`value` attribute reports a normalized value between 0 (too\n        close to measure) and 1 (maximum distance). This parameter specifies\n        the maximum distance expected in meters. This defaults to 1.\n    \"\"\"\n    def __init__(self, echo, trigger, max_distance=1):\n        self._pin_nums = (echo, trigger)\n        self._max_distance = max_distance\n        self._echo = Pin(echo, mode=Pin.IN, pull=Pin.PULL_DOWN)\n        self._trigger = Pin(trigger, mode=Pin.OUT, value=0)\n        \n    def _read(self):\n        echo_on = None\n        echo_off = None\n        timed_out = False\n        \n        self._trigger.off()\n        sleep(0.000005)\n        self._trigger.on()\n        sleep(0.00001)\n        self._trigger.off()\n\n        # If an echo isn't measured in 100 milliseconds, it should\n        # be considered out of range. The maximum length of the\n        # echo is 38 milliseconds but it's not known how long the\n        # transmission takes after the trigger\n        stop = ticks_ms() + 100\n        while echo_off is None and not timed_out:\n            if self._echo.value() == 1 and echo_on is None:\n                echo_on = ticks_us()\n            if echo_on is not None and self._echo.value() == 0:\n                echo_off = ticks_us()\n            if ticks_ms() > stop:\n                timed_out = True\n            \n        if echo_off is None or timed_out:\n            return None\n        else:\n            distance = ((echo_off - echo_on) * 0.000343) / 2\n            distance = min(distance, self._max_distance)\n            return distance\n    \n    @property\n    def value(self):\n        \"\"\"\n        Returns a value between 0, indicating the reflector is either touching \n        the sensor or is sufficiently near that the sensor canâ€™t tell the \n        difference, and 1, indicating the reflector is at or beyond the \n        specified max_distance. A return value of None indicates that the\n        echo was not received before the timeout.\n        \"\"\"\n        distance = self.distance\n        return distance / self._max_distance if distance is not None else None\n    \n    @property\n    def distance(self):\n        \"\"\"\n        Returns the current distance measured by the sensor in meters. Note \n        that this property will have a value between 0 and max_distance.\n        \"\"\"\n        return self._read()\n\n    @property\n    def max_distance(self):\n        \"\"\"\n        Returns the maximum distance that the sensor will measure in metres.\n        \"\"\"\n        return self._max_distance\n\n```\n\n```py picow-led-microcontroller/src/secrets.py\nSSID = \"\"\nPASS = \"\"\n```\n\n\nThis is a micropython project for a picow microcontroller. Could you try to find out how the range is setup for the picow device? What do i need to change if i want to use a range from 0 to 100?\nTo set up the range for the Picow microcontroller to operate within a 0-100 scale, you will need to adjust the `gpio.py` file. Specifically, you should modify the `set_range` method and how it's used in setting PWM duty cycle values.\n\nHere are the steps:\n\n1. **Modify the `set_range` method:**\n\n   In the `gpio.py` file, find the `GPIO` class and locate the `set_range` method:\n\n   ```python\n   def set_range(self, min: int, max: int) -> None:\n       self.data[\"range\"][\"min\"] = min\n       self.data[\"range\"][\"max\"] = max\n       self.cache.write(self.data)\n   ```\n\n2. **Update the calculation within `set_duty`:**\n\n   In the same class, locate and modify the `_value_to_state` method where it calculates the duty cycle:\n\n   ```python\n   def _value_to_state(self, value):\n       return int((1 - (value / self.data[\"range\"][\"max\"])) * U16_MAX)\n   ```\n\n   Change this to accommodate a 0-100 scale instead of the default 0-255 range for PWM:\n\n   ```python\n   def _value_to_state(self, value):\n       return int((1 - (value / self.data[\"range\"][\"max\"])) * 65535)\n   ```\n\n3. **Set the range when initializing:**\n\n   After loading the settings from cache in the `__init__` method of the `GPIO` class, set a default range if none is found:\n\n   ```python\n   def __init__(self):\n       self.cache = Cache(\"gpio\")\n       self.data = {\n           \"pins\": [],\n           \"range\": {\n               \"min\": 0,\n               \"max\": 100,  # Set default range from 0 to 100\n           },\n       }\n\n       data = self.cache.read()\n       if isinstance(data, dict):\n           self.data = data\n\n       self._pins = []\n       self._duty = []\n       self.setup()\n   ```\n\n4. **Adjusting PWM range:**\n\n   If you want the output to directly map 0-100 to the desired PWM duty cycle, update `_value_to_state` accordingly:\n\n   ```python\n   def _value_to_state(self, value):\n       return int((value / self.data[\"range\"][\"max\"]) * U16_MAX)\n   ```\n\n5. **Testing:**\n\n   After making these changes, upload your code to the Picow microcontroller and test by setting values within the 0-100 range using the `led_set_color` command (or equivalent) from the client-side interface you have set up.\n\nBy following these steps, you will configure the Picow microcontroller's PWM range to operate on a 0-100 scale. This adjustment affects how inputs and outputs are interpreted as duty cycle values for LEDs or other PWM-capable devices connected to it.\nIs there a way tiny go can handle all of this? I remember there was still a problem with handling the wifi\n\nYes, it's possible to create an equivalent system using TinyGo on your Picow microcontroller. However, you would need to adapt some parts of the code as Go does not have direct equivalents for some Python libraries used in this project.\n\nHere is how you could proceed:\n\n1. **Set up network (Wi-Fi):**\n\n   TinyGo provides a `net` package that allows establishing a Wi-Fi connection. You can use it similar to how sockets work in Python. Here's an example of how to establish a TCP server using the Go language:\n\n   ```go\n   import (\n       \"fmt\"\n       \"net\"\n   )\n\n   func main() {\n       conn, err := net.Listen(\"tcp\", \":3000\")\n       if err != nil {\n           fmt.Println(err)\n           return\n       }\n\n       defer conn.Close()\n\n       for {\n           client, err := conn.Accept()\n           if err != nil {\n               fmt.Println(err)\n               continue\n           }\n\n           go handleClient(client)\n       }\n   }\n\n   func handleClient(client net.Conn) {\n       // Handle the connection with your logic here...\n   }\n   ```\n\n2. **Create a server loop:**\n\n   Use similar code as above to create a TCP server that listens for incoming connections and handles each client in a separate goroutine.\n\n3. **Parse JSON data from clients:**\n\n   TinyGo's `encoding/json` package allows parsing JSON data. Similar to Python, you would need to define structs matching the expected JSON structure and then use `json.Unmarshal()` to decode incoming data:\n\n   ```go\n   type Command struct {\n       Id      int         `json:\"id\"`\n       Group   string      `json:\"group\"`\n       Type    string      `json:\"type\"`\n       Command string      `json:\"command\"`\n       Args    interface{} `json:\"args\"`\n   }\n\n   func handleClient(client net.Conn) {\n       // Read data from the client...\n       buf := make([]byte, 1024)\n       n, err := client.Read(buf)\n       if err != nil {\n           fmt.Println(err)\n           return\n       }\n\n       var command Command\n       if err := json.Unmarshal(buf[:n], &command); err != nil {\n           // Handle error...\n           continue\n       }\n       // ...and process the command.\n   }\n   ```\n\n4. **Control GPIO devices:**\n\n   TinyGo supports controlling GPIO pins using its `machine` package. You can set up PWM, digital I/O, and other peripherals similarly to how you would in C or Assembly for an AVR microcontroller.\n\n5. **Manage state between requests (optional):**\n\n   Depending on your application's requirements, you might need a way to manage the current GPIO states between different client requests. TinyGo doesn't provide a built-in database system like Python does, so you'll have to use external storage or in-memory data structures.\n\nRemember that TinyGo has a limited memory footprint and fewer libraries compared to Python. If your application's requirements grow beyond what can be handled with TinyGo alone, you might need to consider using more advanced microcontrollers or serverless solutions.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":267}}},{"id":{"replica_id":0,"value":102},"start":77389,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":268}}},{"id":{"replica_id":0,"value":103},"start":79802,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":269}}},{"id":{"replica_id":0,"value":259},"start":79910,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":270}}},{"id":{"replica_id":0,"value":260},"start":82866,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":271}}}],"summary":"Range Setup for Picow Microcontroller","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":4,"end":77193},"icon":"Folder","label":"picow-led-microcontroller/src","metadata":null},{"range":{"start":34,"end":1622},"icon":"File","label":"picow-led-microcontroller/src/commands.py","metadata":{"path":"picow-led-microcontroller/src/commands.py"}},{"range":{"start":1623,"end":1786},"icon":"File","label":"picow-led-microcontroller/src/constants.py","metadata":{"path":"picow-led-microcontroller/src/constants.py"}},{"range":{"start":1787,"end":4750},"icon":"File","label":"picow-led-microcontroller/src/gpio.py","metadata":{"path":"picow-led-microcontroller/src/gpio.py"}},{"range":{"start":4751,"end":9177},"icon":"File","label":"picow-led-microcontroller/src/main.py","metadata":{"path":"picow-led-microcontroller/src/main.py"}},{"range":{"start":9178,"end":77120},"icon":"File","label":"picow-led-microcontroller/src/picozero.py","metadata":{"path":"picow-led-microcontroller/src/picozero.py"}},{"range":{"start":77121,"end":77192},"icon":"File","label":"picow-led-microcontroller/src/secrets.py","metadata":{"path":"picow-led-microcontroller/src/secrets.py"}}],"thought_process_output_sections":[]}